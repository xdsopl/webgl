<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Isosurface</title>

<script id="vertex-shader" type="x-shader/x-vertex">
attribute vec2 attribute_vertex_position;
uniform vec3 uniform_camera_up;
uniform vec3 uniform_camera_right;
uniform vec3 uniform_camera_dir;
uniform float uniform_camera_near;
uniform float uniform_zoom;
varying vec3 varying_pixel_position;
void main()
{
	gl_Position = vec4(attribute_vertex_position, 0.0, 1.0);
	varying_pixel_position =
		attribute_vertex_position[0] / uniform_zoom * uniform_camera_right +
		attribute_vertex_position[1] / uniform_zoom * uniform_camera_up +
		uniform_camera_near * uniform_camera_dir;
}
</script>

<script id="argb-srgb" type="x-shader/x-fragment">
float srgb(float v)
{
	v = clamp(v, 0.0, 1.0);
	float K0 = 0.03928;
	float a = 0.055;
	float phi = 12.92;
	float gamma = 2.4;
	return v <= K0 / phi ? v * phi : (1.0 + a) * pow(v, 1.0 / gamma) - a;
}
float linear(float v)
{
	v = clamp(v, 0.0, 1.0);
	float K0 = 0.03928;
	float a = 0.055;
	float phi = 12.92;
	float gamma = 2.4;
	return v <= K0 ? v / phi : pow((v + a) / (1.0 + a), gamma);
}
vec4 argb(vec3 c)
{
	return vec4(srgb(c.r), srgb(c.g), srgb(c.b), 1.0);
}
</script>

<script id="argb-linear" type="x-shader/x-fragment">
vec4 argb(vec3 c)
{
	return vec4(c, 1.0);
}
</script>

<script id="fragment-structs" type="x-shader/x-fragment">
struct struct_interval
{
	float min, max;
};
struct struct_surface
{
	vec3 p, n;
	float l;
	bool t;
};
struct struct_ray
{
	vec3 o, d;
	float near, far;
};
struct struct_sphere {
	vec3 c;
	float r;
};
</script>

<script id="red-green-shader" type="x-shader/x-fragment">
vec3 color(struct_surface surface, struct_ray ray)
{
	float v = surface.t ? dot(surface.n, ray.d) : 0.0;
	return v < 0.0 ? vec3(0.0, -v, 0.0) : vec3(v, 0.0, 0.0);
}
</script>

<script id="boring-shader" type="x-shader/x-fragment">
vec3 color(struct_surface surface, struct_ray ray)
{
	return vec3(surface.t ? abs(dot(surface.n, ray.d)) : 0.0);
}
</script>

<script id="fancy-shader" type="x-shader/x-fragment">
vec3 color(struct_surface surface, struct_ray ray)
{
	return (surface.t ? abs(dot(surface.n, ray.d)) : 0.0) * surface.p;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
varying vec3 varying_pixel_position;
uniform vec3 uniform_camera_origin;
uniform float uniform_camera_near;
uniform float uniform_camera_far;
uniform float uniform_a;
uniform float uniform_radius;
bool sphere_ray(out struct_interval l, struct_sphere sphere, struct_ray ray)
{
	vec3 dst = sphere.c - ray.o;
	float b = dot(dst, ray.d);
	float c = dot(dst, dst) - sphere.r * sphere.r;
	float d = b * b - c;
	float q = sqrt(d);
	float l0 = b - q;
	float l1 = b + q;
	l.min = max(l0, ray.near);
	l.max = min(l1, ray.far);
	return d >= 0.0 && l0 < ray.far && l1 > ray.near;
}
float func(vec3 v, float a)
{
	return func_xyza(v.x, v.y, v.z, a);
}
vec3 gradient(vec3 v, float a)
{
	return vec3(deriv_x(v.x, v.y, v.z, a), deriv_y(v.x, v.y, v.z, a), deriv_z(v.x, v.y, v.z, a));
}
bool sign_change(float a, float b)
{
	return a * b < 0.0;
}
float bisect(struct_interval l, struct_ray ray, float a)
{
	struct_interval k = l;
	vec3 p0 = k.min * ray.d + ray.o;
	float v0 = func(p0, a);
	for (int i = 0; i < 20; i++) {
		float x = 0.5 * (k.min + k.max);
		vec3 p1 = x * ray.d + ray.o;
		bool test = sign_change(v0, func(p1, a));
		k.min = test ? k.min : x;
		k.max = test ? x : k.max;
	}
	return 0.5 * (k.min + k.max);
}
float newton(float n, struct_ray ray, float a)
{
	for (int i = 0; i < 20; i++) {
		vec3 p = n * ray.d + ray.o;
		n -= func(p, a) / dot(ray.d, gradient(p, a));
	}
	return n;
}
bool localize(inout struct_interval l, struct_ray ray, float a)
{
	float coarse = 0.05;
	float fine = 0.001;
	struct_interval k = l;
	vec3 p0 = k.min * ray.d + ray.o;
	float v0 = func(p0, a);
	bool test = false;
//	while (test || k.min >= l.max) {
	for (int i = 0; i < 150; i++) {
		float x = v0 / dot(ray.d, gradient(p0, a));
		float step = clamp(abs(x), fine, coarse);
		k.max = test ? k.max : k.min + step;
		vec3 p1 = k.max * ray.d + ray.o;
		float v1 = func(p1, a);
		test = test || k.max < l.max && sign_change(v0, v1);
		k.min = test ? k.min : k.max;
		v0 = v1;
		p0 = p1;
		if (test || k.min >= l.max)
			break;
	}
	l.min = test ? k.min : l.min;
	l.max = test ? k.max : l.max;
	return test;
}
void main()
{
	float a = uniform_a;
	struct_ray ray;
	ray.d = normalize(varying_pixel_position);
	ray.o = uniform_camera_origin;
	ray.near = uniform_camera_near;
	ray.far = uniform_camera_far;
	struct_interval l;
	if (!sphere_ray(l, struct_sphere(vec3(0.0, 0.0, 0.0), uniform_radius), ray))
		discard;
	struct_surface surface;
	surface.t = localize(l, ray, a);
	if (!surface.t)
		discard;
	surface.l = newton(bisect(l, ray, a), ray, a);
	surface.p = surface.l * ray.d + ray.o;
	surface.n = normalize(gradient(surface.p, a));
	gl_FragColor = argb(color(surface, ray));
}
</script>

<script type="text/javascript">
var canvas, gl, attribute_vertex_position, quad_buffer;
var color_shader;
var camera = {
	up : [ 0.0, 1.0, 0.0 ],
	right : [ 1.0, 0.0, 0.0 ],
	dir : [ 0.0, 0.0, -1.0 ],
	origin : [ 0.0, 0.0, 10.0 ],
	near: 5.0,
	far : 100.0
};
var uniform_camera_up, uniform_camera_right, uniform_camera_origin;
var uniform_camera_dir, uniform_camera_near, uniform_camera_far;
var value_a, radius, zoom;
var uniform_a, uniform_radius, uniform_zoom;
var last_x, last_y;
var request = 0;
function update()
{
	gl.clear(gl.COLOR_BUFFER_BIT);
	gl.uniform3f(uniform_camera_up, camera.up[0], camera.up[1], camera.up[2]);
	gl.uniform3f(uniform_camera_right, camera.right[0], camera.right[1], camera.right[2]);
	gl.uniform3f(uniform_camera_origin, camera.origin[0], camera.origin[1], camera.origin[2]);
	gl.uniform3f(uniform_camera_dir, camera.dir[0], camera.dir[1], camera.dir[2]);
	gl.uniform1f(uniform_camera_near, camera.near);
	gl.uniform1f(uniform_camera_far, camera.far);
	gl.uniform1f(uniform_a, value_a);
	gl.uniform1f(uniform_radius, radius);
	gl.uniform1f(uniform_zoom, zoom);
	gl.bindBuffer(gl.ARRAY_BUFFER, quad_buffer);
	gl.vertexAttribPointer(attribute_vertex_position, 2, gl.FLOAT, false, 0, 0);
	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	request = 0;
}
function draw()
{
	if (!request)
		request = window.requestAnimationFrame(update);
}
var func_xyza_str;
var deriv_x, deriv_y, deriv_z;
var parser_left;
var parser_right;
var parser_op;
var parser_op_begin;
var parser_op_end;
var parser_str;
var parser_stack;
function stack()
{
	this.items = new Array();
	this.empty = function()
	{
		return 0 == this.items.length;
	}
	this.top = function()
	{
		return this.items[this.items.length - 1];
	}
	this.pop = function()
	{
		return this.items.pop();
	}
	this.push = function(item)
	{
		this.items.push(item);
	}
}
function stack_item(node, token, begin, end)
{
	this.node = node;
	this.token = token;
	this.begin = begin;
	this.end = end;
}
function error(msg, begin, end)
{
	var tmp = parser_str + "\n";
	for (var i = 0; i < begin; i++)
		tmp += " ";
	for (var i = begin; i <= end; i++)
		tmp += "~";
	tmp += "\n" + msg;
	document.getElementById("func-output").innerHTML = tmp;
	return false;
}
function a2f(s)
{
	var r = 0.0;
	var i = 0;
	while (i < s.length && '0' <= s[i] && s[i] <= '9')
		r = 10.0 * r + (s[i++] - '0');
	if ('.' != s[i++])
		return r;
	var d = 10.0;
	while (i < s.length && '0' <= s[i] && s[i] <= '9') {
		r += (s[i++] - '0') / d;
		d *= 10.0;
	}
	return r;
}
var token_err = 0;
var token_x = 1;
var token_y = 2;
var token_z = 3;
var token_a = 4;
var token_add = 5;
var token_sub = 6;
var token_mul = 7;
var token_div = 8;
var token_neg = 9;
var token_num = 10;
var token_pow = 11;
var token_sqrt = 12;
var token_sin = 13;
var token_cos = 14;
var token_paran = 15;
function token_node(left, token, right)
{
	this.left = left;
	this.right = right;
	this.token = token;
}
function num_leaf(value)
{
	this.token = token_num;
	this.value = value;
}
function pow_node(left, exponent)
{
	this.left = left;
	this.token = token_pow;
	this.value = exponent;
}
function token_span(left, token, right, begin, end)
{
	this.left = left;
	this.right = right;
	this.token = token;
	this.begin = begin;
	this.end = end;
}
function unary_span(token, right, begin, end)
{
	this.right = right;
	this.token = token;
	this.begin = begin;
	this.end = end;
}
function num_span(value, begin, end)
{
	this.token = token_num;
	this.value = value;
	this.begin = begin;
	this.end = end;
}
function pow_span(left, exponent, begin, end)
{
	this.left = left;
	this.token = token_pow;
	this.value = exponent;
	this.begin = begin;
	this.end = end;
}
function var_span(token, begin, end)
{
	this.token = token;
	this.begin = begin;
	this.end = end;
}
function token_prio(token)
{
	switch (token) {
		case token_paran:
			return -1;
		case token_sqrt:
		case token_sin:
		case token_cos:
			return 4;
		case token_pow:
			return 3;
		case token_div:
			return 2;
		case token_mul:
			return 1;
		case token_add:
		case token_sub:
		case token_neg:
		default:
			return 0;
	}
}
function integer(f)
{
	return f == Math.round(f);
}
function is_num(node)
{
	return node.token == token_num;
}
function is_zero(node)
{
	return is_num(node) && 0.0 == node.value;
}
function is_one(node)
{
	return is_num(node) && 1.0 == node.value;
}
function func_add(a, b)
{
	return a + b;
}
function func_mul(a, b)
{
	return a * b;
}
function commutative(node, token, func)
{
	if (is_num(node.left) && token == node.right.token && is_num(node.right.left)) {
		node.left = new num_leaf(func(node.left.value, node.right.left.value));
		node.right = node.right.right;
		return node;
	}
	if (token == node.left.token && is_num(node.left.left) && token == node.right.token && is_num(node.right.left)) {
		node.left.left = new num_leaf(func(node.left.left.value, node.right.left.value));
		node.right.left = node.left.right;
		node.left.right = node.right;
		return node.left;
	}
	if (token == node.left.token && is_num(node.left.left)) {
		var tmp = node.left;
		node.left = tmp.left;
		tmp.left = node.right;
		node.right = tmp;
		return node;
	}
	if (token == node.right.token && is_num(node.right.left)) {
		var tmp = node.right.left;
		node.right.left = node.left;
		node.left = tmp;
		return node;
	}
	return node;
}
function reduce(node)
{
	switch (node.token) {
		case token_x:
		case token_y:
		case token_z:
		case token_a:
		case token_num:
			return node;
		case token_pow:
			if (0.0 == node.value)
				return new num_leaf(1.0);
			if (1.0 == node.value)
				return reduce(node.left);
			if (is_zero(node.left) || is_one(node.left))
				return node.left;
			if (is_num(node.left))
				return new num_leaf(Math.pow(node.left.value, node.value));
			node.left = reduce(node.left);
			if (is_zero(node.left) || is_one(node.left))
				return node.left;
			if (is_num(node.left))
				return new num_leaf(Math.pow(node.left.value, node.value));
			return node;
		case token_mul:
			if (is_zero(node.left) || is_zero(node.right))
				return new num_leaf(0.0);
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value * node.right.value);
			if (is_one(node.left))
				return reduce(node.right);
			if (is_one(node.right))
				return reduce(node.left);
			node.left = reduce(node.left);
			if (is_zero(node.left))
				return node.left;
			node.right = reduce(node.right);
			if (is_zero(node.right))
				return node.right;
			if (!is_num(node.left) && is_num(node.right)){
				var tmp = node.left;
				node.left = node.right;
				node.right = tmp;
			}
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value * node.right.value);
			if (is_one(node.left))
				return reduce(node.right);
			if (is_one(node.right))
				return reduce(node.left);
			return commutative(node, token_mul, func_mul);
		case token_div:
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value / node.right.value);
			if (is_zero(node.left))
				return node.left;
			if (is_one(node.right))
				return reduce(node.left);
			node.left = reduce(node.left);
			if (is_zero(node.left))
				return node.left;
			node.right = reduce(node.right);
			if (is_one(node.right))
				return node.left;
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value / node.right.value);
			if (is_num(node.right))
				return new token_node(new num_leaf(1.0 / node.right.value), token_mul, node.left);
			return node;
		case token_add:
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value + node.right.value);
			if (is_zero(node.left))
				return reduce(node.right);
			if (is_zero(node.right))
				return reduce(node.left);
			node.left = reduce(node.left);
			node.right = reduce(node.right);
			if (is_zero(node.left))
				return node.right;
			if (is_zero(node.right))
				return node.left;
			if (!is_num(node.left) && is_num(node.right)) {
				var tmp = node.left;
				node.left = node.right;
				node.right = tmp;
			}
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value + node.right.value);
			return commutative(node, token_add, func_add);
		case token_sub:
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value - node.right.value);
			if (is_zero(node.right))
				return reduce(node.left);
			node.left = reduce(node.left);
			node.right = reduce(node.right);
			if (is_zero(node.right))
				return node.left;
			if (is_num(node.left) && is_num(node.right))
				return new num_leaf(node.left.value - node.right.value);
			if (is_zero(node.left)) {
				node.left = 0;
				node.token = token_neg;
				return node;
			}
			return node;
		case token_neg:
			if (is_num(node.right))
				return new num_leaf(-node.right.value);
			node.right = reduce(node.right);
			if (is_num(node.right))
				return new num_leaf(-node.right.value);
			return node;
		case token_sqrt:
			if (is_num(node.right))
				return new num_leaf(Math.sqrt(node.right.value));
			node.right = reduce(node.right);
			if (is_num(node.right))
				return new num_leaf(Math.sqrt(node.right.value));
			return node;
		case token_sin:
			if (is_num(node.right))
				return new num_leaf(Math.sin(node.right.value));
			node.right = reduce(node.right);
			if (is_num(node.right))
				return new num_leaf(Math.sin(node.right.value));
			return node;
		case token_cos:
			if (is_num(node.right))
				return new num_leaf(Math.cos(node.right.value));
			node.right = reduce(node.right);
			if (is_num(node.right))
				return new num_leaf(Math.cos(node.right.value));
			return node;
		case token_err:
		default:
			return token_err;
	}
}
function deriv(node, token)
{
	switch (node.token) {
		case token_x:
			if (token_x == token)
				return new num_leaf(1.0);
			else
				return new num_leaf(0.0);
		case token_y:
			if (token_y == token)
				return new num_leaf(1.0);
			else
				return new num_leaf(0.0);
		case token_z:
			if (token_z == token)
				return new num_leaf(1.0);
			else
				return new num_leaf(0.0);
		case token_a:
			if (token_a == token)
				return new num_leaf(1.0);
			else
				return new num_leaf(0.0);
		case token_num:
			return new num_leaf(0.0);
		case token_pow:
			return new token_node(
				deriv(node.left, token),
				token_mul,
				new token_node(
					new num_leaf(node.value),
					token_mul,
					new pow_node(
						node.left,
						node.value-1.0
					)
				)
			);
		case token_mul:
			return new token_node(
				new token_node(
					deriv(node.left, token),
					token_mul,
					node.right
				),
				token_add,
				new token_node(
					node.left,
					token_mul,
					deriv(node.right, token)
				)
			);
		case token_add:
			return new token_node(
				deriv(node.left, token),
				token_add,
				deriv(node.right, token)
			);
		case token_sub:
			return new token_node(
				deriv(node.left, token),
				token_sub,
				deriv(node.right, token)
			);
		case token_neg:
			return new token_node(0, token_neg, deriv(node.right, token));
		case token_err:
		default:
			return token_err;
	}
}
function handle_pow(left, right)
{
	var right_begin = right.begin;
	var right_end = right.end;
	if (token_num != right.token)
		right = reduce(right);
	if (token_num != right.token)
		return error("exponent does not reduce to number", right_begin, right_end);
	if (token_num != left.token && !integer(right.value))
		return error("exponent not integer", right_begin, right_end);
	if (right.value < 0.0)
		return error("exponent is negative", right_begin, right_end);
	return new pow_span(left, right.value, left.begin, right_end);
}
function handle_div(left, right)
{
	var right_begin = right.begin;
	var right_end = right.end;
	if (token_num != right.token)
		right = reduce(right);
	if (token_num != right.token)
		return error("divisor does not reduce to number", right_begin, right_end);
	if (0.0 == right.value)
		return error("divisor is zero", right_begin, right_end);
	return new token_span(left, token_div, right, left.begin, right_end);
}
function handle_sqrt(right, begin)
{
	var right_begin = right.begin;
	var right_end = right.end;
	if (token_num != right.token)
		right = reduce(right);
	if (token_num != right.token)
		return error("argument does not reduce to number", right_begin, right_end);
	if (0.0 > right.value)
		return error("argument is negative", right_begin, right_end);
	return new unary_span(token_sqrt, right, begin, right_end);
}
function handle_sin(right, begin)
{
	var right_begin = right.begin;
	var right_end = right.end;
	if (token_num != right.token)
		right = reduce(right);
	if (token_num != right.token)
		return error("argument does not reduce to number", right_begin, right_end);
	return new unary_span(token_sin, right, begin, right_end);
}
function handle_cos(right, begin)
{
	var right_begin = right.begin;
	var right_end = right.end;
	if (token_num != right.token)
		right = reduce(right);
	if (token_num != right.token)
		return error("argument does not reduce to number", right_begin, right_end);
	return new unary_span(token_cos, right, begin, right_end);
}
function handle_node(left, token, right, begin, end)
{
	switch (token) {
		case token_pow:
			return handle_pow(left, right);
		case token_div:
			return handle_div(left, right);
		case token_sqrt:
			return handle_sqrt(right, begin);
		case token_sin:
			return handle_sin(right, begin);
		case token_cos:
			return handle_cos(right, begin);
		default:
			return new token_span(left, token, right, left ? left.begin : begin, right ? right.end : end);
	}
}
function operand(node)
{
	if (!parser_left && !parser_op) {
		parser_left = node;
	} else if (parser_op && !parser_right) {
		parser_right = node;
	} else {
		return error("syntax error", node.begin, node.end);
	}
	return true;
}
function binary_operator(token, begin, end)
{
	if (parser_left && !parser_op) {
		parser_op = token;
		parser_op_begin = begin;
		parser_op_end = end;
	} else if (parser_op && parser_right) {
		if (token_prio(parser_op) >= token_prio(token)) {
			parser_left = handle_node(parser_left, parser_op, parser_right, parser_op_begin, parser_op_end);
			if (!parser_left)
				return false;
			parser_op = token;
			parser_op_begin = begin;
			parser_op_end = end;
			parser_right = 0;
		} else {
			parser_stack.push(new stack_item(parser_left, parser_op, parser_op_begin, parser_op_end));
			parser_left = parser_right;
			parser_op = token;
			parser_op_begin = begin;
			parser_op_end = end;
			parser_right = 0;
			return true;
		}
	} else {
		return error("syntax error", begin, end);
	}
	while (!parser_stack.empty() && token_prio(parser_stack.top().token) >= token_prio(parser_op)) {
		var item = parser_stack.pop();
		parser_left = handle_node(item.node, item.token, parser_left, item.begin, item.end);
		if (!parser_left)
			return false;
	}
	return true;
}
function unary_operator(token, begin, end)
{
	if (!parser_left && !parser_op) {
		parser_op = token;
		parser_op_begin = begin;
		parser_op_end = end;
		return true;
	} else if (parser_op && !parser_right) {
		parser_stack.push(new stack_item(parser_left, parser_op, parser_op_begin, parser_op_end));
		parser_left = 0;
		parser_op = token;
		parser_op_begin = begin;
		parser_op_end = end;
		parser_right = 0;
		return true;
	} else {
		return error("syntax error", begin, end);
	}
}
function opening_paran(pos)
{
	if (!parser_left && !parser_op) {
		parser_stack.push(new stack_item(0, token_paran, pos, pos));
	} else if (parser_op && !parser_right) {
		parser_stack.push(new stack_item(parser_left, parser_op, parser_op_begin, parser_op_end));
		parser_stack.push(new stack_item(0, token_paran, pos, pos));
		parser_left = 0;
		parser_op = 0;
		parser_right = 0;
	} else {
		return error("syntax error", pos, pos);
	}
	return true;
}
function closing_paran(pos)
{
	if (parser_op && parser_right) {
		parser_left = handle_node(parser_left, parser_op, parser_right, parser_op_begin, parser_op_end);
		if (!parser_left)
			return false;
		parser_op = 0;
		parser_right = 0;
	} else if (!parser_left) {
		return error("syntax error", pos, pos);
	}
	while (!parser_stack.empty() && parser_stack.top().token != token_paran) {
		var item = parser_stack.pop();
		parser_left = handle_node(item.node, item.token, parser_left, item.begin, item.end);
		if (!parser_left)
			return false;
	}
	if (parser_stack.empty())
		return error("opening parenthese missing", pos, pos);
	parser_stack.pop();
	if (!parser_stack.empty() && parser_stack.top().token != token_paran) {
		var item = parser_stack.pop();
		parser_right = parser_left;
		parser_op = item.token;
		parser_op_begin = item.begin;
		parser_op_end = item.end;
		parser_left = item.node;
	}
	return true;
}
function parse()
{
	var str = document.getElementById("func-input").value;
	parser_str = str;
	parser_left = 0;
	parser_right = 0;
	parser_op = 0;
	parser_op_begin = 0;
	parser_op_end = 0;
	parser_stack = new stack();
	for (var pos = 0; pos < str.length; pos++) {
		switch (str[pos]) {
			case ' ':
				break;
			case '.':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				var begin = pos;
				var dot = 0;
				while (pos < str.length && ('0' <= str[pos] && str[pos] <= '9' || '.' == str[pos])) {
					if ('.' == str[pos] && ++dot > 1)
						return error("there can be only one", pos, pos);
					pos++;
				}
				pos--;
				if (!operand(new num_span(a2f(str.substr(begin, pos-begin+1)), begin, pos)))
					return false;
				break;
			case 'x':
				if (!operand(new var_span(token_x, pos, pos)))
					return false;
				break;
			case 'y':
				if (!operand(new var_span(token_y, pos, pos)))
					return false;
				break;
			case 'z':
				if (!operand(new var_span(token_z, pos, pos)))
					return false;
				break;
			case 'a':
				if (!operand(new var_span(token_a, pos, pos)))
					return false;
				break;
			case 'c':
				if ("cos" != str.substr(pos, 3))
					return error("unkown", pos, pos);
				if (!unary_operator(token_cos, pos, pos+2))
					return false;
				pos += 2;
				break;
			case 's':
				if ("sqrt" == str.substr(pos, 4)) {
					if (!unary_operator(token_sqrt, pos, pos+3))
						return false;
					pos += 3;
				} else if ("sin" == str.substr(pos, 3)) {
					if (!unary_operator(token_sin, pos, pos+2))
						return false;
					pos += 2;
				} else {
					return error("unkown", pos, pos);
				}
				break;
			case 'P':
				if ("PI" != str.substr(pos, 2))
					return error("unkown", pos, pos);
				if (!operand(new num_span(Math.PI, pos, pos+1)))
					return false;
				pos += 1;
				break;
			case '^':
				if (!binary_operator(token_pow, pos, pos))
					return false;
				break;
			case '*':
				if (!binary_operator(token_mul, pos, pos))
					return false;
				break;
			case '/':
				if (!binary_operator(token_div, pos, pos))
					return false;
				break;
			case '+':
				if (!binary_operator(token_add, pos, pos))
					return false;
				break;
			case '-':
				if (parser_left || parser_op) {
					if (!binary_operator(token_sub, pos, pos))
						return false;
				} else {
					if (!unary_operator(token_neg, pos, pos))
						return false;
				}
				break;
			case '(':
				if (!opening_paran(pos))
					return false;
				break;
			case ')':
				if (!closing_paran(pos))
					return false;
				break;
			default:
				return error("unkown", pos, pos);
		}
	}
	if (parser_op && parser_right) {
		parser_left = handle_node(parser_left, parser_op, parser_right, parser_op_begin, parser_op_end);
		if (!parser_left)
			return false;
	} else if (parser_op || parser_right) {
		return error("incomplete expression", str.length-1, str.length-1);
	}
	while (!parser_stack.empty() && parser_stack.top().token != token_paran) {
		var item = parser_stack.pop();
		parser_left = handle_node(item.node, item.token, parser_left, item.begin, item.end);
		if (!parser_left)
			return false;
	}
	if (!parser_stack.empty())
		return error("closing parenthese missing", str.length-1, str.length-1);

	document.getElementById("func-output").innerHTML = "";
	return parser_left;
}
var emit_counter;
var emit_str;
function emit_num(value)
{
	emit_str += "\tfloat _" + emit_counter + " = " + value.toFixed(15) + ";\n";
	return emit_counter++;
}
function emit_var(name)
{
	emit_str += "\tfloat _" + emit_counter + " = " + name + ";\n";
	return emit_counter++;
}
function emit_vec(name)
{
	emit_str += "\tfloat _" + emit_counter + " = " + name + ";\n";
	return emit_counter++;
}
function emit_mul(left, right)
{
	emit_str += "\tfloat _" + emit_counter + " = _" + left + " * _" + right + ";\n";
	return emit_counter++;
}
function emit_div(left, right)
{
	emit_str += "\tfloat _" + emit_counter + " = _" + left + " / _" + right + ";\n";
	return emit_counter++;
}
function emit_add(left, right)
{
	emit_str += "\tfloat _" + emit_counter + " = _" + left + " + _" + right + ";\n";
	return emit_counter++;
}
function emit_sub(left, right)
{
	emit_str += "\tfloat _" + emit_counter + " = _" + left + " - _" + right + ";\n";
	return emit_counter++;
}
function emit_neg(right)
{
	emit_str += "\tfloat _" + emit_counter + " = - _" + right + ";\n";
	return emit_counter++;
}
function emit_pow(base, exp)
{
	if (0 == exp)
		return emit_num(1);
	else if (1 == exp)
		return base;
	else if (exp & 1)
		return emit_mul(base, emit_pow(emit_mul(base, base), (exp - 1) / 2));
	else
		return emit_pow(emit_mul(base, base), exp / 2);
}
function emit(node)
{
	switch (node.token) {
		case token_x:
			return emit_vec("x");
		case token_y:
			return emit_vec("y");
		case token_z:
			return emit_vec("z");
		case token_a:
			return emit_var("a");
		case token_num:
			return emit_num(node.value);
		case token_pow:
			return emit_pow(emit(node.left), node.value);
		case token_mul:
			return emit_mul(emit(node.left), emit(node.right));
		case token_div:
			return emit_div(emit(node.left), emit(node.right));
		case token_add:
			return emit_add(emit(node.left), emit(node.right));
		case token_sub:
			return emit_sub(emit(node.left), emit(node.right));
		case token_neg:
			return emit_neg(emit(node.right));
		default:
			return -1;
	}
}
function compile()
{
	var vertex_shader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertex_shader, document.getElementById("vertex-shader").text);
	gl.compileShader(vertex_shader);

	if (!gl.getShaderParameter(vertex_shader, gl.COMPILE_STATUS)) {
		alert("vertex shader:\n" + gl.getShaderInfoLog(vertex_shader));
		return;
	}

	var fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);
	var source = "precision highp float;\n";
	source += document.getElementById("fragment-structs").text;
	source += func_xyza_str;
	source += deriv_x_str;
	source += deriv_y_str;
	source += deriv_z_str;
	if (document.getElementById("srgb-toggle").innerHTML == "disable")
		source += document.getElementById("argb-srgb").text;
	else
		source += document.getElementById("argb-linear").text;
	source += document.getElementById(color_shader).text;
	source += document.getElementById("fragment-shader").text;
	gl.shaderSource(fragment_shader, source);
	gl.compileShader(fragment_shader);

	if (!gl.getShaderParameter(fragment_shader, gl.COMPILE_STATUS)) {
		alert("fragment shader:\n" + gl.getShaderInfoLog(fragment_shader));
		return;
	}

	var program = gl.createProgram();
	gl.attachShader(program, vertex_shader);
	gl.attachShader(program, fragment_shader);
	gl.linkProgram(program);

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		alert("linker error:\n" + gl.getProgramInfoLog(program));
		return;
	}

	gl.useProgram(program);

	attribute_vertex_position = gl.getAttribLocation(program, "attribute_vertex_position");
	gl.enableVertexAttribArray(attribute_vertex_position);
	uniform_camera_up = gl.getUniformLocation(program, "uniform_camera_up");
	uniform_camera_right = gl.getUniformLocation(program, "uniform_camera_right");
	uniform_camera_origin = gl.getUniformLocation(program, "uniform_camera_origin");
	uniform_camera_dir = gl.getUniformLocation(program, "uniform_camera_dir");
	uniform_camera_near = gl.getUniformLocation(program, "uniform_camera_near");
	uniform_camera_far = gl.getUniformLocation(program, "uniform_camera_far");
	uniform_a = gl.getUniformLocation(program, "uniform_a");
	uniform_radius = gl.getUniformLocation(program, "uniform_radius");
	uniform_zoom = gl.getUniformLocation(program, "uniform_zoom");
}
function build(name, node)
{
	emit_str = "float " + name + "(float x, float y, float z, float a)\n{\n";
	emit_counter = 0;
	var ret = emit(node);
	emit_str += "\treturn _" + ret + ";\n}\n";
	return emit_str;
}
function engage()
{
	var func_xyza = parse();
	if (!func_xyza)
		return;
	func_xyza = reduce(func_xyza);
	var deriv_x = reduce(deriv(func_xyza, token_x));
	var deriv_y = reduce(deriv(func_xyza, token_y));
	var deriv_z = reduce(deriv(func_xyza, token_z));
	func_xyza_str = build("func_xyza", func_xyza);
	deriv_x_str = build("deriv_x", deriv_x);
	deriv_y_str = build("deriv_y", deriv_y);
	deriv_z_str = build("deriv_z", deriv_z);
	document.getElementById("func-output").innerHTML = "";//func_xyza_str + deriv_x_str + deriv_y_str + deriv_z_str;
	compile();
	draw();
}
function v3_normalize(v)
{
	var l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
	return [ v[0] / l, v[1] / l, v[2] / l ];
}
function v3_cross(a, b)
{
	return [
		a[1] * b[2] - a[2] * b[1],
		a[2] * b[0] - a[0] * b[2],
		a[0] * b[1] - a[1] * b[0]
	];
}
function m4_rot(v, a)
{
	var c = Math.cos(a);
	var s = Math.sin(a);
	return [
		v[0]*v[0]*(1.0-c)+c,		v[0]*v[1]*(1.0-c)-v[2]*s,	v[0]*v[2]*(1.0-c)+v[1]*s,	0.0,
		v[1]*v[0]*(1.0-c)+v[2]*s,	v[1]*v[1]*(1.0-c)+c,		v[1]*v[2]*(1.0-c)-v[0]*s,	0.0,
		v[2]*v[0]*(1.0-c)-v[1]*s,	v[2]*v[1]*(1.0-c)+v[0]*s,	v[2]*v[2]*(1.0-c)+c,		0.0,
		0.0,				0.0,				0.0,				1.0
	];
}
function m4v3_mul(m, v)
{
	return [
		m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3],
		m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7],
		m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11],
		m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15]
	];
}
function m4_mul(a, b)
{
	return [
		a[0]*b[0]+a[1]*b[4]+a[2]*b[8]+a[3]*b[12], a[0]*b[1]+a[1]*b[5]+a[2]*b[9]+a[3]*b[13], a[0]*b[2]+a[1]*b[6]+a[2]*b[10]+a[3]*b[14], a[0]*b[3]+a[1]*b[7]+a[2]*b[11]+a[3]*b[15],
		a[4]*b[0]+a[5]*b[4]+a[6]*b[8]+a[7]*b[12], a[4]*b[1]+a[5]*b[5]+a[6]*b[9]+a[7]*b[13], a[4]*b[2]+a[5]*b[6]+a[6]*b[10]+a[7]*b[14], a[4]*b[3]+a[5]*b[7]+a[6]*b[11]+a[7]*b[15],
		a[8]*b[0]+a[9]*b[4]+a[10]*b[8]+a[11]*b[12], a[8]*b[1]+a[9]*b[5]+a[10]*b[9]+a[11]*b[13], a[8]*b[2]+a[9]*b[6]+a[10]*b[10]+a[11]*b[14], a[8]*b[3]+a[9]*b[7]+a[10]*b[11]+a[11]*b[15],
		a[12]*b[0]+a[13]*b[4]+a[14]*b[8]+a[15]*b[12], a[12]*b[1]+a[13]*b[5]+a[14]*b[9]+a[15]*b[13], a[12]*b[2]+a[13]*b[6]+a[14]*b[9]+a[15]*b[14], a[12]*b[3]+a[13]*b[7]+a[14]*b[11]+a[15]*b[15]
	];
}
function mouse_move(event)
{
	var x = event.clientX;
	var y = event.clientY;
	var x_rel = (x - last_x) / canvas.width;
	var y_rel = (last_y - y) / canvas.height;
	last_x = x;
	last_y = y;
	var rot_x = m4_rot(camera.right, Math.PI * y_rel);
	var rot_y = m4_rot(camera.up, - Math.PI * x_rel);
	var rotation = m4_mul(rot_x, rot_y);
	camera.origin = m4v3_mul(rotation, camera.origin);
	camera.up = v3_normalize(m4v3_mul(rotation, camera.up));
	camera.right = v3_normalize(m4v3_mul(rotation, camera.right));
	camera.dir = v3_cross(camera.up, camera.right);
	draw();
}
function mouse_down(event)
{
	last_x = event.clientX;
	last_y = event.clientY;
	document.addEventListener("mousemove", mouse_move, false);
}
function mouse_up(event)
{
	document.removeEventListener("mousemove", mouse_move, false);
}
function set_a(a)
{
	value_a = a;
	document.getElementById("a-output").innerHTML = "a=" + a;
	document.getElementById("a-input").value = a;
}
function set_radius(r)
{
	radius = r;
	document.getElementById("radius-output").innerHTML = "radius=" + r;
	document.getElementById("radius-input").value = r;
}
function set_zoom(z)
{
	zoom = z;
	document.getElementById("zoom-output").innerHTML = "zoom=" + z;
	document.getElementById("zoom-input").value = z;
}
function set_func(a, z, r, str)
{
	set_a(a);
	set_radius(r);
	set_zoom(z);
	document.getElementById("func-input").value = str;
	engage();
}
function heart()
{
	set_func(1, 1, 1.5, "(2*x^2 + y^2 + z^2 - 1)^3 - x^2*z^3/10 - y^2*z^3");
}
function torus()
{
	set_func(1, 0.4, 3, "(x^2 + y^2 + z^2 + 2)^2 - 12*(x^2 + y^2)");
}
function cross()
{
	set_func(1, 1, 1, "x*y*z");
}
function paraboloid()
{
	set_func(1, 0.5, 3, "x^2 + y^2 + z - 1");
}
function cone()
{
	set_func(1, 1, 1, "x^2 + y^2 - z^2");
}
function cylinder()
{
	set_func(1, 0.5, 2, "x^2 + y^2 - 1");
}
function chmutov()
{
	set_func(1, 0.8, 1.8, "128*x^8-256*x^6+160*x^4-32*x^2+128*y^8-256*y^6+160*y^4-32*y^2+128*z^8-256*z^6+160*z^4-32*z^2+4*a");
}
function sextic()
{
	set_func(1, 0.4, 3, "4*((a*(1+sqrt(5))/2)^2*x^2-1*y^2)*((a*(1+sqrt(5))/2)^2*y^2-1*z^2)*((a*(1+sqrt(5))/2)^2*z^2-1*x^2)-1*(1+2*(a*(1+sqrt(5))/2))*(x^2+y^2+z^2-1*1)^2");
}
function start()
{
	canvas = document.getElementById("canvas");
	gl = canvas.getContext("webgl");
	if (!gl)
		gl = canvas.getContext("experimental-webgl");

	if (!gl) {
		alert("could not get webgl context");
		return;
	}

	gl.clearColor(0.0, 0.0, 0.0, 1.0);

	quad_buffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, quad_buffer);
	var vertices = [ 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0 ];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

	color_shader = "red-green-shader";
	sextic();

	canvas.addEventListener("mousedown", mouse_down, false);
	document.addEventListener("mouseup", mouse_up, false);
}
function set_shader(str)
{
	color_shader = str + "-shader";
	compile();
	draw();
}
function toggle(button)
{
	if (button.innerHTML == "disable") {
		button.innerHTML = "enable";
	} else {
		button.innerHTML = "disable";
	}
	compile();
	draw();
}
</script>
</head>

<body onload="start();" style="color: silver; background-color: black">
<p>toggle srgb correction: <button id="srgb-toggle" onclick="toggle(this);">disable</button> choose color shader: <button onclick="set_shader('red-green');">red-green</button><button onclick="set_shader('boring');">boring</button><button onclick="set_shader('fancy');">fancy</button></p>
<p><button onclick="heart();">heart</button><button onclick="torus();">torus</button><button onclick="cross();">cross</button><button onclick="paraboloid();">paraboloid</button><button onclick="cone();">cone</button><button onclick="cylinder();">cylinder</button><button onclick="chmutov();">chmutov</button><button onclick="sextic();">sextic</button></p>
<p><input type="range" id="a-input" onchange="set_a(this.value); draw();" min="0" max="1" step="0.01" value="1"><span id="a-output">a=1</span></p>
<p><input type="range" id="radius-input" onchange="set_radius(this.value); draw();" min="0.25" max="5" step="0.01" value="1"><span id="radius-output">radius=1</span></p>
<p><input type="range" id="zoom-input" onchange="set_zoom(this.value); draw();" min="0.25" max="5" step="0.01" value="1"><span id="zoom-output">zoom=1</span></p>
<canvas id="canvas" style="border: none; cursor: default;" width="512" height="512">
WebGL not enabled?
</canvas>
<p>enter function "f(x, y, z, a)" for the visualization of its isosurface "f(x, y, z, a) = 0":<p>
<p><input id="func-input" type="text" size="128" onchange="engage();" value=""></p>
<pre id="func-output"></pre>
<footer><small>
isosurface.html - visualizing the zero set of a function using GLSL in WebGL<br />
Written in 2013 by &lt;Ahmet Inan&gt; &lt;xdsopl@googlemail.com&gt;<br />
To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.<br />
You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see <a href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</a>.
</small></footer>
</body>

</html>
